using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace Fahrenheit.Tools.CT2CS;

[XmlType("CheatEntry")]
[DebuggerDisplay("{Description}, {CheatEntries.Count} descendants")]
public sealed class FhCtEntry
{
    // hack
    private string _description;

    public string Description
    {
        get  { return _description; }
        init { _description = value.Replace("\"", ""); }
    }

    public uint            ID           { get; init; }
    public uint            ShowAsSigned { get; init; }
    public string          VariableType { get; init; } = string.Empty;
    public string          Address      { get; init; } = string.Empty;
    public List<FhCtEntry> CheatEntries { get; init; } = new List<FhCtEntry>();
    public uint            BitStart     { get; init; }
    public uint            BitLength    { get; init; }
    public uint            GroupHeader  { get; init; }

    public FhCtEntry()
    {
        _description = string.Empty;

        Address      = string.Empty;
        VariableType = string.Empty;
        CheatEntries = new List<FhCtEntry>();
    }
}

public        record FhSyntaxNode(string Name);
public sealed record FhStructNode(string Name, string Offset, string Size, List<FhSyntaxNode> Fields) : FhSyntaxNode(Name);
public        record FhVarNode(string Name, string Offset) : FhSyntaxNode(Name);
public sealed record FhBitfieldVarNode(string Name, string Offset, uint BitStart, uint BitLength) : FhVarNode(Name, Offset);
public sealed record FhStandardVarNode(string Name, string Offset, string TypeName) : FhVarNode(Name, Offset);

public static class FhCtSyntaxExtensions
{
    public static bool BfvnFieldAlreadyGenerated(this FhBitfieldVarNode bfvn, in List<FhBitfieldVarNode> bfvns)
    {
        foreach (FhBitfieldVarNode node in bfvns)
        {
            if (node.Offset == bfvn.Offset)
            {
                bfvns.Add(bfvn);
                return true;
            }
        }

        bfvns.Add(bfvn);
        return false;
    }

    public static bool TryEmitStruct(this FhStructNode stn, StringBuilder sb)
    {
        List<FhBitfieldVarNode> bfvnCache = new List<FhBitfieldVarNode>();

        sb.AppendLine(EmitPrologue(stn));

        foreach (FhSyntaxNode field in stn.Fields)
        {
            switch (field)
            {
                case FhStandardVarNode svn:
                    sb.AppendLine(svn.EmitStandardVarNode()); break;
                case FhStructNode estn:
                    sb.AppendLine(estn.EmitStructRef()); break;
                case FhBitfieldVarNode bfvn:
                {
                    if (!BfvnFieldAlreadyGenerated(bfvn, bfvnCache))
                        sb.AppendLine(bfvn.EmitBitfieldVarBackingField());

                    sb.AppendLine(bfvn.EmitBitfieldVarNode());
                    break;
                }
            }
        }

        sb.AppendLine($"}}\n");

        return true;
    }

    public static string EmitPrologue(this FhStructNode stn)
    {
        return $$"""
/* [ct2cs {{DateTime.UtcNow.ToString("dd/M/yy HH:mm")}}]
 * This file was generated by Fahrenheit.CT2CS (https://github.com/fkelava/fahrenheit/).
 * 
 * Source file: {{Path.GetFileName(CT2CSConfig.SrcPath)}}
 */

namespace {{CT2CSConfig.DefaultNamespace}};

[StructLayout(LayoutKind.Explicit, Pack = 4, Size = {{stn.Size}})]
public struct {{stn.Name}} 
{
""";
    }

    public static string EmitStructRef(this FhStructNode stn)
    {
        return $"    [FieldOffset(0x{stn.Offset})] public {stn.Name} __{stn.Name}_0x{stn.Offset};";
    }

    public static string EmitStandardVarNode(this FhStandardVarNode svn) 
    {
        return $"    [FieldOffset(0x{svn.Offset})] public {svn.TypeName} {svn.Name};";
    }

    public static string EmitBitfieldVarNode(this FhBitfieldVarNode bfvn)
    {
        return $"    public int {bfvn.Name} {{ get {{ return (__0x{bfvn.Offset}{(bfvn.BitStart == 0 ? "" : $" >> {bfvn.BitStart}")}) & 1; }} }}";
    }

    public static string EmitBitfieldVarBackingField(this FhBitfieldVarNode bfvn)
    {
        return $"    [FieldOffset(0x{bfvn.Offset})] public byte __0x{bfvn.Offset};";
    }
}

public static class FhCheatEntryExtensions
{
    public static bool IsStructDef(this FhCtEntry ce)
    {
        return ce.GroupHeader == 1;
    }

    public static bool IsVar(this FhCtEntry ce)
    {
        return ce.TryGetVarTypeName(out _);
    }

    public static bool IsVarBitfield(this FhCtEntry ce)
    {
        return ce.VariableType == "Binary";
    }

    public static bool TryConstructSyntaxNode(this FhCtEntry ce, [NotNullWhen(true)] out FhSyntaxNode? sn)
    {
        sn = default;

        if (ce.TryConstructStructNode(out FhStructNode? stn))
        {
            sn = stn;
            return true;
        }

        if (ce.TryConstructVarNode(out FhVarNode? vn))
        {
            sn = vn;
            return true;
        }

        return false;
    }

    public static bool TryConstructStructNode(this FhCtEntry ce, [NotNullWhen(true)] out FhStructNode? stn)
    {
        stn = default;
        if (!ce.IsStructDef()) return false;

        List<FhSyntaxNode> fields = new List<FhSyntaxNode>();

        foreach (FhCtEntry descendant in ce.CheatEntries)
        {
            if (descendant.TryConstructSyntaxNode(out FhSyntaxNode? sn))
            {
                fields.Add(sn);
            }
        }

        string offset = ce.TryGetFieldOffset(out string offsetStr) ? offsetStr : "0";

        stn = new FhStructNode(ce.VarNameFromDescr(), offset, ce.StructSizeFromDescr(), fields);
        return true;
    }

    public static bool TryConstructVarNode(this FhCtEntry ce, [NotNullWhen(true)] out FhVarNode? vn)
    {
        vn = default;
        if (!ce.IsVar() && !ce.IsVarBitfield()) return false;

        string vname = ce.VarNameFromDescr();
        if (!ce.TryGetFieldOffset(out string voffs)) return false;

        vn = ce.VariableType == "Binary"
            ? new FhBitfieldVarNode(vname, voffs, ce.BitStart, ce.BitLength)
            : new FhStandardVarNode(vname, voffs, ce.TryGetVarTypeName(out string vtype) ? vtype : throw new Exception("E_NO_TYPE"));
        return true;
    }

    public static bool TryGetVarTypeName(this FhCtEntry ce, out string varTypeName)
    {
        varTypeName = ce.VariableType switch
        {
            "Byte"    => ce.ShowAsSigned == 1 ? "sbyte" : "byte",
            "2 Bytes" => ce.ShowAsSigned == 1 ? "short" : "ushort",
            "4 Bytes" => ce.ShowAsSigned == 1 ? "int" : "uint",
            "8 Bytes" => ce.ShowAsSigned == 1 ? "long" : "ulong",
            "Float"   => "float",
            _         => string.Empty
        };

        return varTypeName != string.Empty;
    }

    public static string VarNameFromDescr(this FhCtEntry ce)
    {
        string descr = ce.Description;
        return descr.Contains(' ') ? descr[0..descr.IndexOf(' ')] : descr;
    }

    public static string StructSizeFromDescr(this FhCtEntry ce)
    {
        string descr = ce.Description;
        return descr[(descr.IndexOf('(') + 1)..descr.IndexOf(')')];
    }

    public static bool TryGetFieldOffset(this FhCtEntry ce, out string offsetStr)
    {
        string addr = ce.Address;
        offsetStr = addr[1..];
        return addr[0] == '+' && uint.TryParse(offsetStr, NumberStyles.HexNumber, null, out _);
    }
}
